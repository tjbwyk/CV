function [R, t] = ICP(B, T, TOL, TIME)

    % Tranform to homogeneous coordinates
    B_homo = [B, ones(length(B), 1)]';
    T_homo = [T, ones(length(T), 1)]';

    % Initialize R, and identity matrix I
    R = eye(3, 3);

    % Initialize t = 0
    t = zeros(1, 3);
    
    % Initialize transformation matrix Tr under homogeneous coordinates
    Tr = eye(4);
    
    % Build KDTree based on target cloud
    KDTree = KDTreeSearcher(T, 'distance', 'euclidean');
    
    % Initialize error
    e_last = 0;
    e = 1e10;

    for i = 1 : TIME
        
        % Update the base cloud
        B_homo_trans = Tr * B_homo;
        
        % Find the closest point for each point in tranformed B to any point in T using KDTree
        [IDX, D] = knnsearch(KDTree, B_homo_trans(1:3, :)');

        % Get matched points from B and T
        B_match_point_indexes = [1:size(IDX)]';
        T_match_point_indexes = IDX;

        B_homo_match_points = B_homo_trans(:, B_match_point_indexes);
        T_homo_match_points = T_homo(:, T_match_point_indexes);

        % Calculate centroid of matched points
        % and sifted to the origin of coordinate system
        [B_homo_centroid, B_homo_shifted] = calculate_centroid(B_homo_match_points);
        [T_homo_centroid, T_homo_shifted] = calculate_centroid(T_homo_match_points);

        % Merge 2 point clouds
        % Matrix multiplication operation
        W = T_homo_shifted(1:3, :) * B_homo_shifted(1:3, :);

        % Apply SVD
        [U, S, V] = svd(W);

        % Calculate rotation matrix
        R = U * V';

        % Calculate translation matrix
        t = T_homo_centroid(1:3) - R * B_homo_centroid(1:3);
        
        % Calculate the homogeneous transformation matrix
        Tr(1:3, :) = [R, t];

        % Calculate new average distance target point clouds
        e_last = e;
        e = mean(abs(D));
        
        % Stop iteration if difference of average distance is less than 
        if abs(e - e_last) / max(e_last, e) < TOL
            break;
        end
    end

end
